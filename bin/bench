#!/usr/bin/perl
use strict;
use warnings;
use 5.010;
use Cwd qw{abs_path};
use File::Basename;
use File::Find;
use Data::Dumper;
use Scalar::Util qw{looks_like_number};
use YAML qw{LoadFile};
sub D (@){print Dumper(@_)}; #so I'm lazy 

# what are we to be doing?
my $default_cmd = 'report';
my $cmd = (main->can($ARGV[0])) ? shift @ARGV : $default_cmd;
my $count = 100;

#---------------------------------------------------------------------------
#  What languages, problems, and solutions are available
#---------------------------------------------------------------------------
# where are we in the filesystem?
my $root_dir = [fileparse(abs_path(__FILE__))]->[1];
my $config   = LoadFile($root_dir . 'config.yaml');  # config is relative to this file
my $base_dir = basename($root_dir);
$root_dir =~ s/(.*)$base_dir.?/$1/; # cd ..

# a list of all the languages, what problems have what solutions
my $solutions = {};
find(sub{ my $p = $File::Find::name; 
          $p =~ s/$root_dir//; 
          my ($lang,$prob,$solution) = split /[\/]/, $p;
          $solutions->{$lang}->{$prob}->{$solution} = $File::Find::name
            if $lang !~ m/^(?:bin|inc|[.]git)/ 
            && defined $lang        # language should be in a useful format
            && length $lang
            && defined $solution    # we should have a solution
            && length $solution     
            && $solution !~ m/^[.]/ # hide any 'hidden' file
            ;
        }, $root_dir);

# a quick list of available problems, just to make the next step easy
my $problems = { map{$_ => 1} map{keys %$_} values %$solutions};

# build out a hash of what was requiested via @ARGV
my $requested = {};
sub mk_prob{ sprintf q{%03d}, shift }           
map{ $_ = mk_prob($_) if looks_like_number($_); # standardize the problem numbers
     $_ = $config->{alias}->{$_} || $_;         # alias the input based on the config
     my $where = ($problems->{$_} ) ? 'prob'    # decide what were doing by the type of data given
               : ($solutions->{$_}) ? 'lang'
               :                      'opt';
     $requested->{$where}->{$_} = 1;            # build a hash so we can uniqui-fy the values
   } @ARGV;
map{ $requested->{$_} = [sort keys %{$requested->{$_}}] } keys %$requested; #revert the unique values to an arrayref
# !!TODO!! ? default should be that if a language/problem was not given then you want everything ?

# build out the 'command' to run pulling the right interp and files
my $runs = {};
map{ my $lang=$_; 
     map { my $interp = $_;
           map{ my $prob = $_;
                map{ push @{$runs->{$lang}->{$prob}->{$_}}, join ' ', $interp, $_;
                   } sort values %{$solutions->{$lang}->{$prob}}
                                                        #4 get the right file paths for the problem
              } @{$requested->{prob}}                   #3 for every problem that was requested
         } @{ $config->{interp}->{$lang} }              #2 for every interep for that language in the config
   } @{$requested->{lang}};                             #1 for every language requested


D $runs;
D $requested;


sub run_command {}



#---------------------------------------------------------------------------
#  Run the right function for the output
#---------------------------------------------------------------------------
sub report {
   D {SOL => $solutions};
}
sub data {
}
sub graph {
}

