#!/usr/bin/perl
use 5.010;
use App::Rad;
use Data::Dumper;
use File::Fu;

sub D (@) {print Dumper(@_)}

sub setup {
   my $c = shift;

   # what commands to learn, ignoring private and debugging
   $c->register_commands( { -ignore_regexp => '^(_.*|D|Dumper)$' } );
   $c->stash->{max_problem} = 252; # http://projecteuler.net/index.php?section=problems&page=6
   map{ $c->stash->{problem}->{sprintf q{%03d},$_} = 1; } 1..$c->stash->{max_problem};

   # whare are we in the dir tree?
   my $root_path = File::Fu->THIS_FILE->absolute->dirname->dirname->stringify;
   $c->stash->{root_path} = $root_path;

   # build out some data so that we can build our report
   # currently this is: what languages have we used, 
   #                    what problems have been solved in what languages (how many instances)
   map   {my ($lang,$prob) = split /\//, $_; 
          $c->stash->{implementation}->{$lang} = 1;
          $c->stash->{solved}->{$lang}->{$prob} = scalar(
                                                   grep{m/^\d+[_.]/} 
                                                   File::Fu->dir( $c->stash->{root_path}."/$_")->absolute->contents
                                                  ) ;
   } grep{m{/.*/}
   } map {$_ = $_->stringify; 
          s/$root_path//; 
          $_
   } File::Fu->THIS_FILE->absolute->dirname->dirname->find(sub{!m/(?:bin|[.]git)/ && -d}) ;

   # now lets parse out what was passed to us via ARGV
   foreach (@ARGV) {
      if ($c->stash->{implementation}->{$_}) {
         push @{$c->options->{implementation}}, $_;
      }
      else {
         my $p = sprintf( q{%03d}, $_);
         push @{$c->options->{problem}}, $p 
            if $c->stash->{problem}->{$p};
      }
   }
}; 


sub default { report(@_) }; 
#sub report :Help(Output a report of all problems done on what languages. --done will restrict to just the problems with solutions.)  {
sub report :Help(How we doin'? restrict by asking for something, --done will limit to only problems solved)  {
   my $c = shift;
   my ($imp,$prob) = map{ $c->options->{$_} || [keys %{$c->stash->{$_}}] } qw{implementation problem};
   my $fmt = join( ' ', q{%4s}, map {sprintf qq{%%%ds}, length($_) } @$imp )."\n";
   printf $fmt, ' ', @$imp; #header
   map { my $p = $_; #keep the problem number
         printf $fmt, $p, map { $c->stash->{solved}->{$_}->{$p} || 0 } @$imp
           unless $c->options->{done} && !grep{defined && $_>0}map{$c->stash->{solved}->{$_}->{$p}} @$imp;
   } sort @$prob;
   undef; #stops the count of the map from being returned
};   

App::Rad->run();
